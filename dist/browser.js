/* Auto-generated by scripts/build-browser.js
 * Date: 2026-02-22T08:26:03.427Z
 * Contains PDL JS library, exposed for browser environments.
 */

(function (global) {
const PDL_LIB = (() => {
/* PDL: Prompt Data Language
* 
* Port from Langflow/Python
*
*/

// ================================================================
// 1) Constants & Config
// ================================================================

const PDL = {
  VALUE_PREFIX: '[value:',
  GET_PREFIX: '[get:',
  SET_PREFIX: '[set:',
  LOOP_IDX: '[loop-index]',

  IF_START: '[if:',
  ELIF: '[if-elif:',
  ELSE: '[if-else]',
  IF_END: '[if-end]',

  LOOP_START: '[loop:',
  LOOP_END: '[loop-end]',

  CONDENSE_START: '[condense]',
  CONDENSE_END: '[condense-end]',

  OPS2: new Set(['<=', '>=', '!=', '^=', '$=', '*=']),
  OPS1: new Set(['<', '>', '=']),
  NUMERIC_OPS: new Set(['<', '<=', '>', '>=']),

  MAX_DEPTH: 40,
  MAX_EXPANSIONS: 30000,

  DATE_TZ: 'Europe/Berlin',
  INVALID_DATE_DEFAULT: '[invalid date]',
  INVALID_TIME_DEFAULT: '[invalid time]',
};

const VAR_NAME_RE = /^[A-Za-z0-9_]+$/;

// ================================================================
// 2) Utilities
// ================================================================

function compactJson(value) {
  try {
    return JSON.stringify(value);
  } catch {
    return String(value);
  }
}

function normalizeStr(v) {
  if (typeof v !== 'string') return v;
  try {
    return v.normalize('NFC').trim();
  } catch {
    return v.trim();
  }
}

function toBool(s) {
  if (s == null) return null;
  const t = String(s).trim().toLowerCase();
  if (['true', 'yes', 'on', '1'].includes(t)) return true;
  if (['false', 'no', 'off', '0'].includes(t)) return false;
  return null;
}

function markdownEscape(s) {
  if (typeof s !== 'string') return s;
  let out = s.replace(/\\/g, '\\\\');
  for (const ch of ['*', '_', '`', '~', '[', ']', '(', ')', '#', '+', '-', '!', '>', '|']) {
    out = out.split(ch).join('\\' + ch);
  }
  return out;
}

function coerceNumber(x) {
  if (typeof x === 'number' && Number.isFinite(x)) return x;
  if (typeof x !== 'string') return null;

  const s = x.trim();
  const NUMERIC_RE = /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?$/;
  if (!NUMERIC_RE.test(s)) return null;

  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

function bumpExp(stats, n = 1) {
  stats.expansions += n;
  if (stats.expansions > PDL.MAX_EXPANSIONS) {
    stats.errors_parse++;
    stats.halted = true;
    return false;
  }
  return true;
}

function plural(n, singular) {
  return n === 1 ? singular : `${singular}s`;
}

// ---- date/time helpers ----
function pad(num, len = 2) {
  const s = String(Math.trunc(Math.abs(num)));
  return s.padStart(len, '0');
}

function renderTokens(fmt, comp, mode) {
  const s = String(fmt || '');
  let out = '';
  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    if (ch !== '%') { out += ch; continue; }
    if (i + 1 >= s.length) { out += '%'; continue; }
    const t = s[i + 1];
    if (t === '%') { out += '%'; i++; continue; }

    const map = {
      Y: () => pad(comp.Y, 4),
      y: () => pad(comp.Y % 100, 2),
      m: () => pad(comp.m, 2),
      d: () => pad(comp.d, 2),
      H: () => pad(comp.H, 2),
      M: () => pad(comp.M, 2),
      S: () => pad(comp.S, 2),
      L: () => pad(comp.L, 3),
    };
    if (map[t]) out += map[t]();
    else out += '%' + t;
    i++;
  }
  return out;
}

function parseDateInput(raw) {
  if (raw == null) return [null, false];
  if (raw instanceof Date) {
    const ms = raw.getTime();
    return [Number.isFinite(ms) ? ms : null, ms !== ms];
  }
  const num = coerceNumber(raw);
  if (num != null) {
    const ms = num < 1e12 ? num * 1000 : num;
    return [ms, false];
  }
  const s = String(raw).trim();
  if (!s) return [null, true];
  // Detect timezone presence
  const hasTz = /[zZ]|([+-]\\d{2}:?\\d{2})$/.test(s);
  if (hasTz) {
    const ms = Date.parse(s);
    return [Number.isFinite(ms) ? ms : null, !Number.isFinite(ms)];
  }
  // Naive strings: interpret in PDL.DATE_TZ (Europe/Berlin)
  const baseUtc = Date.parse(s.endsWith('Z') ? s : (s + 'Z'));
  if (!Number.isFinite(baseUtc)) return [null, true];
  const offsetMs = tzOffsetMs(baseUtc, PDL.DATE_TZ);
  return [baseUtc - offsetMs, false];
}

function componentsFromDateMs(ms, tz) {
  const dtf = new Intl.DateTimeFormat('en-GB', {
    timeZone: tz,
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false,
  });
  const parts = dtf.formatToParts(new Date(ms));
  const get = (type) => {
    const p = parts.find(x => x.type === type);
    return p ? parseInt(p.value, 10) : 0;
  };
  return {
    Y: get('year'),
    y: get('year') % 100,
    m: get('month'),
    d: get('day'),
    H: get('hour'),
    M: get('minute'),
    S: get('second'),
    L: Math.floor(ms % 1000),
  };
}

function tzOffsetMs(utcMs, tz) {
  const dtf = new Intl.DateTimeFormat('en-GB', {
    timeZone: tz,
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false,
  });
  const parts = dtf.formatToParts(new Date(utcMs));
  const get = (type) => {
    const p = parts.find(x => x.type === type);
    return p ? parseInt(p.value, 10) : 0;
  };
  const wallMs = Date.UTC(get('year'), get('month') - 1, get('day'), get('hour'), get('minute'), get('second'));
  return wallMs - utcMs;
}

function breakDownDuration(ms) {
  const out = { Y:0,y:0,m:0,d:0,H:0,M:0,S:0,L:0 };
  let total = Math.trunc(ms);
  if (!Number.isFinite(total) || total < 0) return out;
  out.L = total % 1000;
  total = Math.floor(total / 1000);
  out.S = total % 60;
  total = Math.floor(total / 60);
  out.M = total % 60;
  total = Math.floor(total / 60);
  out.H = total % 24;
  total = Math.floor(total / 24);
  out.d = total;
  out.m = Math.floor(out.d / 30);
  out.d = out.d % 30;
  out.Y = Math.floor(out.m / 12);
  out.m = out.m % 12;
  out.y = out.Y % 100;
  return out;
}

function isPureTokenFormat(fmt) {
  const parts = String(fmt || '').trim().split(/\\s+/).filter(Boolean);
  if (!parts.length) return false;
  return parts.every(p => /^%[YymdHMSL]$/.test(p));
}

function applyCaseBasic(s, { upper=false, lower=false, title=false } = {}) {
  if (title) {
    try { return s.replace(/\w\S*/g, w => w[0].toUpperCase() + w.slice(1).toLowerCase()); } catch { return s; }
  }
  if (upper) return s.toUpperCase();
  if (lower) return s.toLowerCase();
  return s;
}

function toWords(s) {
  let x = String(s || '');
  x = x.replace(/[^\w]+/g, ' ');
  x = x.replace(/([a-z0-9])([A-Z])/g, '$1 $2');
  return x.trim().split(/\s+/).filter(Boolean);
}

function camelCase(s, upper) {
  const words = toWords(s);
  if (!words.length) return '';
  const first = words[0].toLowerCase();
  const rest = words.slice(1).map(w => w.slice(0,1).toUpperCase() + w.slice(1).toLowerCase());
  return upper
    ? words.map(w => w.slice(0,1).toUpperCase() + w.slice(1).toLowerCase()).join('')
    : first + rest.join('');
}

function snakeCase(s, upper) {
  const words = toWords(s);
  const base = words.map(w => w.toLowerCase()).join('_');
  return upper ? base.toUpperCase() : base;
}

function applyTruncate(s, limit, suffix) {
  if (!Number.isInteger(limit) || limit <= 0) return s;
  const str = String(s);
  if (suffix != null && suffix !== '') {
    return str.length > limit ? (str.slice(0, limit) + String(suffix)) : str;
  }
  return str.length > limit ? str.slice(0, limit) : str;
}

// ---- args splitting (shlex-ish, no deps) ----
function splitArgs(raw) {
  const s = String(raw || '').trim();
  if (!s) return [];
  const out = [];
  let cur = '';
  let inSingle = false;
  let inDouble = false;
  let esc = false;

  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    if (esc) { cur += ch; esc = false; continue; }
    if (ch === '\\' && (inSingle || inDouble)) { esc = true; cur += ch; continue; }
    if (ch === "'" && !inDouble) { inSingle = !inSingle; cur += ch; continue; }
    if (ch === '"' && !inSingle) { inDouble = !inDouble; cur += ch; continue; }

    if (!inSingle && !inDouble && /\s/.test(ch)) {
      if (cur.trim() !== '') out.push(cur.trim());
      cur = '';
      continue;
    }
    cur += ch;
  }
  if (cur.trim() !== '') out.push(cur.trim());
  return out;
}

function parseKvFlags(raw, { firstPositional=null, types=null, defaults=null } = {}) {
  const s = String(raw || '').trim();
  const data = {};
  if (defaults) Object.assign(data, defaults);
  if (!s) return data;

  let parts;
  try { parts = splitArgs(s); } catch { parts = s.split(/\s+/); }

  if (firstPositional && parts.length) {
    data[firstPositional] = parts[0];
    parts = parts.slice(1);
  }

  for (const token of parts) {
    if (!token.includes('=')) continue;
    const idx = token.indexOf('=');
    const k = token.slice(0, idx);
    const v = token.slice(idx + 1);

    if (types && Object.prototype.hasOwnProperty.call(types, k)) {
      const T = types[k];
      if (T === Boolean) {
        const b = toBool(v);
        data[k] = (b != null) ? b : Boolean(v);
      } else if (T === Number) {
        const n = Number(v);
        data[k] = Number.isFinite(n) ? n : (defaults && k in defaults ? defaults[k] : null);
      } else {
        data[k] = stripOuterQuotes(v);
      }
    } else {
      const low = String(v).toLowerCase();
      if (low === 'true' || low === 'false') data[k] = (low === 'true');
      else data[k] = v;
    }
  }
  return data;
}

function formatIndex(indices, dots) {
  if (!indices || !indices.length) return '0';
  return dots ? indices.join('.') : String(indices[indices.length - 1]);
}

function existsForSuccess(value) {
  if (value == null) return false;
  if (typeof value === 'string' && value === '') return false;
  return true;
}

function applyReplace(s, spec) {
  const str = String(s);
  if (!spec) return str;
  if (spec.startsWith('s/')) {
    const m = spec.match(/^s\/((?:\\.|[^/])*)\/((?:\\.|[^/])*)\/([gimsGIMS]*)$/);
    if (!m) return str;
    const patRaw = m[1].replace(/\\\//g, '/');
    const replRaw = m[2].replace(/\\\//g, '/');
    const flagsRaw = m[3] || '';
    const flagSet = new Set();
    for (const ch of flagsRaw.toLowerCase()) {
      if (['i', 'm', 's', 'g'].includes(ch)) flagSet.add(ch);
    }
    const flags = Array.from(flagSet).join('');
    try { return str.replace(new RegExp(patRaw, flags), replRaw); } catch { return str; }
  }
  for (const part of spec.split(';').filter(p => p !== '')) {
    if (!part.includes(':')) continue;
    const [oldVal, newVal] = part.split(':', 2);
    if (str.includes(oldVal)) {
      return str.split(oldVal).join(newVal);
    }
  }
  return str;
}

function toRenderText(value, stringifyFlag) {
  if (stringifyFlag) {
    try { return JSON.stringify(value); } catch { return String(value); }
  }
  if (value == null) return null;
  if (Array.isArray(value) || (value && typeof value === 'object')) return compactJson(value);
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  return String(value);
}

function parseScalarOrJson(raw) {
  const s = String(raw || '').trim();
  if (s.startsWith('{') || s.startsWith('[')) {
    try { return JSON.parse(s); } catch { return s; }
  }
  if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))) {
    return s.slice(1, -1).replace(/\\"/g, '"').replace(/\\'/g, "'");
  }
  if (s === 'true') return true;
  if (s === 'false') return false;
  if (s === 'null') return null;
  const n = coerceNumber(s);
  if (n != null) return n;
  return s;
}

function escapeRegExp(str) {
  return String(str).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function applyStringVariables(template, vars = {}) {
  let out = String(template || '');
  for (const [k, v] of Object.entries(vars || {})) {
    const val = (v == null) ? '' : String(v);
    out = out.replace(new RegExp(`\\{${escapeRegExp(k)}\\}`, 'g'), val);
  }
  return out;
}

function stripOuterQuotes(v) {
  const s = String(v || '');
  if (s.length >= 2 && ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'")))) {
    return s.slice(1, -1);
  }
  return s;
}

// ================================================================
// 3) Stats & Scope
// ================================================================

class RenderStats {
  constructor() {
    this.loops = 0;
    this.conds_true = 0;
    this.conds_false = 0;
    this.errors_parse = 0;
    this.errors_inline = 0;
    this.expansions = 0;
    this.halted = false;
  }
  summary() {
    const parts = [
      `Expanded ${this.loops} loop(s)`,
      `${this.conds_true + this.conds_false} condition(s)`,
    ];
    if (this.expansions) parts.push(`${this.expansions} expansion(s)`);
    if (this.errors_parse) parts.push(`${this.errors_parse} parse issue(s)`);
    if (this.errors_inline) parts.push(`${this.errors_inline} inline issue(s)`);
    return parts.join('; ');
  }
}

class VarBinding {
  constructor(value, { constFlag=true, humble=false } = {}) {
    this.value = value;
    this.const = constFlag;
    this.humble = humble;
  }
}

class Scope {
  constructor({ root, aliases={}, index_chain=[], dots=true, var_frames=null }) {
    this.root = root;
    this.aliases = aliases;
    this.index_chain = index_chain;
    this.dots = dots;
    this.var_frames = var_frames || [Object.create(null)];
  }

  getVarBinding(name) {
    if (!VAR_NAME_RE.test(String(name || ''))) return [null, null];
    for (let idx = this.var_frames.length - 1; idx >= 0; idx--) {
      const frame = this.var_frames[idx];
      if (Object.prototype.hasOwnProperty.call(frame, name)) return [frame[name], idx];
    }
    return [null, null];
  }

  getVarValue(name) {
    const [b] = this.getVarBinding(name);
    return b ? b.value : null;
  }

  setVar(name, value, {
    scope_local=false,
    constFlag=null,
    humbleFlag=null,
    allow_value_update_if_const_flip=false
  } = {}) {
    if (!VAR_NAME_RE.test(String(name || ''))) return;

    const targetFrameIndex = (scope_local && this.var_frames.length > 0) ? (this.var_frames.length - 1) : 0;
    const targetFrame = this.var_frames[targetFrameIndex];
    const bindingInTarget = targetFrame[name];

    // deletion: only touch target frame
    if (value == null) {
      if (bindingInTarget) delete targetFrame[name];
      return;
    }

    if (!bindingInTarget) {
      targetFrame[name] = new VarBinding(value, {
        constFlag: (constFlag == null) ? true : Boolean(constFlag),
        humble: (humbleFlag == null) ? false : Boolean(humbleFlag),
      });
      return;
    }

    if (constFlag != null) bindingInTarget.const = Boolean(constFlag);
    if (humbleFlag != null) bindingInTarget.humble = Boolean(humbleFlag);

    if (bindingInTarget.const) {
      if (allow_value_update_if_const_flip && constFlag === false) bindingInTarget.value = value;
    } else {
      bindingInTarget.value = value;
    }
  }
}

// ================================================================
// 4) PathResolver (FIXED for alias-first bracket paths + root array unwrap)
// ================================================================

class PathResolver {
  constructor() {
    this.SEGMENT_RE = /(?<name>[A-Za-z_]\w*|"(?:\\.|[^"])+")(?:\[(?<sel>[^\]]*)\])?(?:\.|$)/g;
    this.FIRST_SEGMENT_RE = /^(?<name>[A-Za-z_]\w*|"(?:\\.|[^"])+")(?:\[(?<sel>[^\]]*)\])?(?:\.(?<rest>.*))?$/;
  }

  resolveScoped(path, scope, { default_ci=false } = {}) {
    this.scopeAliases = scope.aliases || {};
    if (typeof path !== 'string' || !path.trim()) return null;
    const p = path.trim();

    // 1) simple var name
    const m0 = p.match(/^([A-Za-z_]\w*)$/);
    if (m0) {
      const name = m0[1];
      const [vb] = scope.getVarBinding(name);
      if (vb) {
        if (vb.humble === false) return vb.value;
        if (Object.prototype.hasOwnProperty.call(scope.aliases, name)) return scope.aliases[name];
        const rv = this._eval(p, scope.root, { default_ci });
        return (rv != null) ? rv : vb.value;
      }
      if (Object.prototype.hasOwnProperty.call(scope.aliases, name)) return scope.aliases[name];
      return this._eval(p, scope.root, { default_ci });
    }

    // 2) base.rest (existing behavior)
    const mdot = p.match(/^("?[A-Za-z_]\w*"?)\.(.+)$/);
    if (mdot) {
      const base = mdot[1];
      const rest = mdot[2];
      const baseKey = base.replace(/^"|"$/g, '');
      const [vb] = scope.getVarBinding(baseKey);

      if (vb) {
        if (vb.humble === false) return this._eval(rest, vb.value, { default_ci });
        if (Object.prototype.hasOwnProperty.call(scope.aliases, baseKey)) return this._eval(rest, scope.aliases[baseKey], { default_ci });
        if (scope.root && typeof scope.root === 'object' && !Array.isArray(scope.root) && Object.prototype.hasOwnProperty.call(scope.root, baseKey)) {
          return this._eval(rest, scope.root[baseKey], { default_ci });
        }
        return this._eval(rest, vb.value, { default_ci });
      }

      if (Object.prototype.hasOwnProperty.call(scope.aliases, baseKey)) return this._eval(rest, scope.aliases[baseKey], { default_ci });
      if (scope.root && typeof scope.root === 'object' && !Array.isArray(scope.root) && Object.prototype.hasOwnProperty.call(scope.root, baseKey)) {
        return this._eval(rest, scope.root[baseKey], { default_ci });
      }
      return null;
    }

    // 3) NEW: alias-first bracket paths like: question[Name Short] or question["Name Short"]
    //    If the path starts with an alias/var, evaluate from that object (Langflow parity).
    const mfirst = p.match(this.FIRST_SEGMENT_RE);
    if (mfirst && mfirst.groups) {
      const nameRaw = mfirst.groups.name;
      const sel = mfirst.groups.sel;
      const rest = mfirst.groups.rest;
      const baseName = nameRaw.replace(/^"|"$/g, '');

      const baseObj = this._resolve_base_identifier(baseName, scope, { default_ci });
      if (baseObj !== undefined) {
        let cur = baseObj;
        if (sel != null) {
          cur = this._apply_bracket_or_selector(cur, sel, { default_ci });
          if (cur === undefined) return null;
        }
        if (rest != null && rest !== '') {
          const rv = this._eval(rest, cur, { default_ci });
          return rv;
        }
        return cur;
      }
    }

    // 4) fall back to root evaluation
    return this._eval(p, scope.root, { default_ci });
  }

  resolveForLoop(path, scope, { default_ci=false } = {}) {
    this.scopeAliases = scope.aliases || {};
    if (typeof path !== 'string' || !path.trim()) return [];
    const p = path.trim();

    // simple name: support alias/var + root unwrap
    const m0 = p.match(/^([A-Za-z_]\w*)$/);
    if (m0) {
      const name = m0[1];
      const baseObj = this._resolve_base_identifier(name, scope, { default_ci });
      if (baseObj !== undefined) {
        const v = baseObj;
        if (Array.isArray(v)) return v;
        return (v == null) ? [] : [v];
      }
      const v = this._eval(name, scope.root, { default_ci });
      if (Array.isArray(v)) return v;
      return (v == null) ? [] : [v];
    }

    // alias-first bracket paths for loops too: e.g. someAlias[something]
    const mfirst = p.match(this.FIRST_SEGMENT_RE);
    if (mfirst && mfirst.groups) {
      const nameRaw = mfirst.groups.name;
      const sel = mfirst.groups.sel;
      const rest = mfirst.groups.rest;
      const baseName = nameRaw.replace(/^"|"$/g, '');
      const baseObj = this._resolve_base_identifier(baseName, scope, { default_ci });

      if (baseObj !== undefined) {
        let cur = baseObj;
        if (sel != null) {
          cur = this._apply_bracket_or_selector(cur, sel, { default_ci });
          if (cur === undefined) return [];
        }
        const v = (rest != null && rest !== '') ? this._evalAll(rest, cur, { default_ci }) : cur;
        if (Array.isArray(v)) return v;
        return (v == null) ? [] : [v];
      }
    }

    const v = this._evalAll(p, scope.root, { default_ci });
    if (Array.isArray(v)) return v;
    return (v == null) ? [] : [v];
  }

  // --- helpers to mimic Langflow’s “humble/alias/vars” priority for base identifiers ---
  _resolve_base_identifier(name, scope, { default_ci=false } = {}) {
    // var binding takes precedence if exists, with humble semantics
    const [vb] = scope.getVarBinding(name);
    if (vb) {
      if (vb.humble === false) return vb.value;
      if (Object.prototype.hasOwnProperty.call(scope.aliases, name)) return scope.aliases[name];
      const rv = this._eval(name, scope.root, { default_ci });
      return (rv != null) ? rv : vb.value;
    }
    if (Object.prototype.hasOwnProperty.call(scope.aliases, name)) return scope.aliases[name];
    // undefined => “not found as base identifier”
    return undefined;
  }

  _parseBracketKey(sel) {
    const s = String(sel || '').trim();
    if (s.length >= 2) {
      const a = s[0], b = s[s.length - 1];
      if ((a === '"' && b === '"') || (a === "'" && b === "'")) {
        let body = s.slice(1, -1);
        body = body.replace(/\\"/g, '"').replace(/\\'/g, "'");
        return body;
      }
    }
    return null;
  }

  _apply_bracket_or_selector(cur, sel, { default_ci=false } = {}) {
    // Object: treat selector as literal key (quoted or unquoted). Supports keys with spaces.
    if (cur && typeof cur === 'object' && !Array.isArray(cur)) {
      const quoted = this._parseBracketKey(sel);
      const key = (quoted != null) ? quoted : String(sel).trim();
      if (Object.prototype.hasOwnProperty.call(cur, key)) return cur[key];
      // optional case-insensitive match for objects if requested
      if (default_ci) {
        const found = Object.keys(cur).find(k => k.toLowerCase() === key.toLowerCase());
        if (found != null) return cur[found];
      }
      return undefined;
    }
    // Array: use selector logic
    if (Array.isArray(cur)) return this._applySelectorFirst(cur, sel, { default_ci });
    return undefined;
  }

  _eval(path, root, { default_ci } = {}) {
    let cur = root;

    // NEW: unwrap single-element array root (common in n8n when JSON emitter returns [ { ... } ])
    if (Array.isArray(cur) && cur.length === 1 && cur[0] && typeof cur[0] === 'object') {
      cur = cur[0];
    }

    const it = path.trim().matchAll(this.SEGMENT_RE);
    let first = true;

    for (const m of it) {
      const nameRaw = m.groups.name;
      const sel = m.groups.sel;
      const name = nameRaw.replace(/^"|"$/g, '');

      // also allow stepping into first element when cur is a single-element array
      if (Array.isArray(cur) && cur.length === 1 && cur[0] && typeof cur[0] === 'object') {
        cur = cur[0];
      }

      if (first && Object.prototype.hasOwnProperty.call(this.scopeAliases || {}, name)) {
        cur = this.scopeAliases[name];
      } else if (cur && typeof cur === 'object' && !Array.isArray(cur) && Object.prototype.hasOwnProperty.call(cur, name)) {
        cur = cur[name];
      } else {
        return null;
      }
      first = false;

      if (sel != null) {
        const applied = this._apply_bracket_or_selector(cur, sel, { default_ci });
        if (applied === undefined) return null;
        cur = applied;
      }
    }
    return cur;
  }

  _evalAll(path, root, { default_ci } = {}) {
    let cur = root;

    if (Array.isArray(cur) && cur.length === 1 && cur[0] && typeof cur[0] === 'object') {
      cur = cur[0];
    }

    const it = path.trim().matchAll(this.SEGMENT_RE);
    let first = true;

    for (const m of it) {
      const nameRaw = m.groups.name;
      const sel = m.groups.sel;
      const name = nameRaw.replace(/^"|"$/g, '');

      if (Array.isArray(cur) && cur.length === 1 && cur[0] && typeof cur[0] === 'object') {
        cur = cur[0];
      }

      if (first && Object.prototype.hasOwnProperty.call(this.scopeAliases || {}, name)) {
        cur = this.scopeAliases[name];
      } else if (cur && typeof cur === 'object' && !Array.isArray(cur) && Object.prototype.hasOwnProperty.call(cur, name)) {
        cur = cur[name];
      } else {
        return [];
      }
      first = false;

      if (sel != null) {
        // object bracket => key, array bracket => selector
        if (cur && typeof cur === 'object' && !Array.isArray(cur)) {
          const quoted = this._parseBracketKey(sel);
          const key = (quoted != null) ? quoted : String(sel).trim();
          if (Object.prototype.hasOwnProperty.call(cur, key)) cur = cur[key];
          else return [];
        } else if (Array.isArray(cur)) {
          cur = this._applySelectorAll(cur, sel, { default_ci });
        } else {
          return [];
        }
      }
    }
    return Array.isArray(cur) ? cur : [cur];
  }

  _splitTopLevel(expr, sep) {
    const out = [];
    let cur = '';
    let inStr = false;
    let esc = false;
    let depth = 0;

    for (const ch of String(expr || '')) {
      if (esc) { cur += ch; esc = false; continue; }
      if (ch === '\\' && inStr) { esc = true; cur += ch; continue; }
      if (ch === '"') { inStr = !inStr; cur += ch; continue; }

      if (!inStr) {
        if (ch === '[') { depth++; cur += ch; continue; }
        if (ch === ']' && depth > 0) { depth--; cur += ch; continue; }
      }

      if (!inStr && depth === 0 && ch === sep) {
        const part = cur.trim();
        if (part) out.push(part);
        cur = '';
        continue;
      }
      cur += ch;
    }
    const last = cur.trim();
    if (last) out.push(last);
    return out;
  }

  _findTopLevelOp(s) {
    let inStr = false;
    let esc = false;
    let depth = 0;

    for (let i = 0; i < s.length; i++) {
      const ch = s[i];
      if (esc) { esc = false; continue; }
      if (ch === '\\' && inStr) { esc = true; continue; }
      if (ch === '"') { inStr = !inStr; continue; }

      if (!inStr) {
        if (ch === '[') { depth++; continue; }
        if (ch === ']' && depth > 0) { depth--; continue; }
        if (depth === 0) {
          if (i + 1 < s.length) {
            const op2 = s.slice(i, i + 2);
            if (PDL.OPS2.has(op2)) return [op2, i];
          }
          if (PDL.OPS1.has(ch)) return [ch, i];
        }
      }
    }
    return [null, -1];
  }

  _parseValueToken(tok) {
    const t = String(tok || '').trim();
    if ((t.startsWith('"') && t.endsWith('"')) || (t.startsWith("'") && t.endsWith("'"))) {
      return t.slice(1, -1).replace(/\\"/g, '"').replace(/\\'/g, "'");
    }
    const n = coerceNumber(t);
    if (n != null) return n;
    if (t === 'true') return true;
    if (t === 'false') return false;
    if (t === 'null') return null;
    return t;
  }

  _extractCi(s) {
    const m = String(s || '').match(/\sci=(true|false)\s*$/i);
    if (m) {
      const ci = m[1].toLowerCase() === 'true';
      return [String(s).slice(0, m.index).trimEnd(), ci];
    }
    return [String(s || ''), false];
  }

  _parsePredicate(expr) {
    const [core] = this._extractCi(expr);
    const orParts = this._splitTopLevel(core, '|');
    const result = [];
    for (const part of orParts) {
      const ands = this._splitTopLevel(part, '&');
      const conds = [];
      for (const c of ands) {
        const [op, pos] = this._findTopLevelOp(c);
        if (!op) continue;
        const key = c.slice(0, pos).trim();
        const val = this._parseValueToken(c.slice(pos + op.length).trim());
        conds.push([key, op, val]);
      }
      if (conds.length) result.push(conds);
    }
    return result;
  }

  _resolvePredicateKey(key, scope, { default_ci } = {}) {
    const k = String(key || '').trim();
    const m = k.match(/^\[get:([A-Za-z0-9_]+)(?:[^\]]*)\]$/);
    if (m) return scope.getVarValue(m[1]);
    return this.resolveScoped(k, scope, { default_ci });
  }

  evalCondition(condExpr, scope, { default_ci=false } = {}) {
    const [chopped, ciIn] = this._extractCi(condExpr);
    const ci = ciIn || default_ci;
    const clauses = this._parsePredicate(chopped);

    if (!clauses.length) {
      const val = this.resolveScoped(chopped, scope, { default_ci: ci });
      return existsForSuccess(val);
    }

    for (const ands of clauses) {
      let okAll = true;
      for (const [k, op, v] of ands) {
        const left = this._resolvePredicateKey(k, scope, { default_ci: ci });
        if (!this._cmp(left, op, v, { case_insensitive: ci })) { okAll = false; break; }
      }
      if (okAll) return true;
    }
    return false;
  }

  _cmp(left, op, right, { case_insensitive=false } = {}) {
    const Lnum = coerceNumber(left);
    const Rnum = coerceNumber(right);
    if (Lnum != null && Rnum != null && (PDL.NUMERIC_OPS.has(op) || op === '=' || op === '!=')) {
      try {
        if (op === '=') return Lnum === Rnum;
        if (op === '!=') return Lnum !== Rnum;
        if (op === '<') return Lnum < Rnum;
        if (op === '<=') return Lnum <= Rnum;
        if (op === '>') return Lnum > Rnum;
        if (op === '>=') return Lnum >= Rnum;
      } catch { return false; }
    }

    let L = normalizeStr(left);
    let R = normalizeStr(right);

    if (typeof L === 'string' && typeof R === 'string') {
      if (case_insensitive) {
        L = L.toLocaleLowerCase();
        R = R.toLocaleLowerCase();
      }
      try {
        if (op === '=') return L === R;
        if (op === '!=') return L !== R;
        if (op === '^=') return L.startsWith(R);
        if (op === '$=') return L.endsWith(R);
        if (op === '*=') return L.includes(R);
      } catch { return false; }
    }

    try {
      if (op === '=') return L === R;
      if (op === '!=') return L !== R;
    } catch { return false; }

    return false;
  }

  _getNested(obj, keyPath) {
    if (keyPath === '') return obj;
    let cur = obj;
    for (const part of String(keyPath).split('.')) {
      if (cur && typeof cur === 'object' && !Array.isArray(cur) && Object.prototype.hasOwnProperty.call(cur, part)) cur = cur[part];
      else return null;
    }
    return cur;
  }

  _applySelectorFirst(arr, selector, { default_ci=false } = {}) {
    const s = String(selector || '').trim();
    if (s === '') return arr.length ? arr[0] : null;
    if (/^\d+$/.test(s)) {
      const idx = parseInt(s, 10);
      return (idx >= 0 && idx < arr.length) ? arr[idx] : null;
    }
    const [core, ciSel] = this._extractCi(s);
    const ci = default_ci || ciSel;
    const clauses = this._parsePredicate(core);
    for (const item of arr) {
      const ok = clauses.some(ands => ands.every(([k, op, v]) => this._cmp(this._getNested(item, k), op, v, { case_insensitive: ci })));
      if (ok) return item;
    }
    return null;
  }

  _applySelectorAll(arr, selector, { default_ci=false } = {}) {
    const s = String(selector || '').trim();
    if (s === '') return [...arr];
    if (/^\d+$/.test(s)) {
      const idx = parseInt(s, 10);
      return (idx >= 0 && idx < arr.length) ? [arr[idx]] : [];
    }
    const [core, ciSel] = this._extractCi(s);
    const ci = default_ci || ciSel;
    const clauses = this._parsePredicate(core);
    const out = [];
    for (const item of arr) {
      const ok = clauses.some(ands => ands.every(([k, op, v]) => this._cmp(this._getNested(item, k), op, v, { case_insensitive: ci })));
      if (ok) out.push(item);
    }
    return out;
  }
}

// ================================================================
// 5) Common helpers (comments + nested expr expansion)
// ================================================================

class CommentHandler {
  static strip(text) {
    const fenceRe = /^(```|~~~)/;
    const lines = String(text || '').split('\n');
    const out = [];
    let inCode = false;

    for (let line of lines) {
      if (fenceRe.test(line)) { inCode = !inCode; out.push(line); continue; }
      if (inCode) { out.push(line); continue; }
      const stripped = line.replace(/^\s+/, '');
      if (stripped.startsWith('//')) continue;
      const m = line.match(/[ \t]\/\//);
      if (m) {
        const cut = m.index;
        line = line.slice(0, cut).replace(/\s+$/, '');
      }
      out.push(line);
    }
    return out.join('\n');
  }
}

function resolveNestedInExpr(expr, scope, resolver) {
  if (!expr) return expr;
  let s = String(expr);

  if (s.includes(PDL.LOOP_IDX)) {
    s = s.split(PDL.LOOP_IDX).join(formatIndex(scope.index_chain, scope.dots));
  }

  function expandAnyToken(segment) {
    // Expand [value:...] inside expressions
    while (segment.includes(PDL.VALUE_PREFIX)) {
      let out = '';
      let pos = 0;
      let changed = false;

      while (pos < segment.length) {
        const k = segment.indexOf(PDL.VALUE_PREFIX, pos);
        if (k === -1) { out += segment.slice(pos); break; }
        out += segment.slice(pos, k);

        let depth = 0;
        let p = k;
        let found = false;
        while (p < segment.length) {
          const ch = segment[p];
          if (ch === '[') depth++;
          else if (ch === ']') {
            depth--;
            if (depth === 0) {
              const inner = segment.slice(k + PDL.VALUE_PREFIX.length, p).trim();
              const innerResolved = resolveNestedInExpr(inner, scope, resolver);
              const val = resolver.resolveScoped(innerResolved, scope, { default_ci: false });
              if (val == null) out += segment.slice(k, p + 1);
              else if (Array.isArray(val) || (val && typeof val === 'object')) out += compactJson(val);
              else if (typeof val === 'boolean') out += (val ? 'true' : 'false');
              else out += String(val);
              pos = p + 1;
              changed = true;
              found = true;
              break;
            }
          }
          p++;
        }
        if (!found) { out += segment.slice(k); pos = segment.length; }
      }

      if (!changed || out === segment) { segment = out; break; }
      segment = out;
    }

    // Expand [get:...] inside expressions
    while (segment.includes(PDL.GET_PREFIX)) {
      let out = '';
      let pos = 0;
      let changed = false;

      while (pos < segment.length) {
        const k = segment.indexOf(PDL.GET_PREFIX, pos);
        if (k === -1) { out += segment.slice(pos); break; }
        out += segment.slice(pos, k);

        let depth = 0;
        let p = k;
        let found = false;
        while (p < segment.length) {
          const ch = segment[p];
          if (ch === '[') depth++;
          else if (ch === ']') {
            depth--;
            if (depth === 0) {
              const innerRaw = segment.slice(k + PDL.GET_PREFIX.length, p).trim();
              const firstSp = innerRaw.search(/\s/);
              const name = (firstSp === -1) ? innerRaw : innerRaw.slice(0, firstSp).trim();
              let val = null;
              if (VAR_NAME_RE.test(name)) val = scope.getVarValue(name);
              if (val == null) out += 'null';
              else if (Array.isArray(val) || (val && typeof val === 'object')) out += compactJson(val);
              else if (typeof val === 'boolean') out += (val ? 'true' : 'false');
              else out += String(val);
              pos = p + 1;
              changed = true;
              found = true;
              break;
            }
          }
          p++;
        }
        if (!found) { out += segment.slice(k); pos = segment.length; }
      }

      if (!changed || out === segment) { segment = out; break; }
      segment = out;
    }

    return segment;
  }

  return expandAnyToken(s);
}

// ================================================================
// 6) Directive layer (inline if/loop + set/get + value expansion)
// ================================================================

class InlineIfHelper {
  static findClosingBracket(s, startPos, endLimit) {
    let inStr = false, esc = false, depth = 0;
    for (let i = startPos; i < endLimit; i++) {
      const ch = s[i];
      if (esc) { esc = false; continue; }
      if (ch === '\\' && inStr) { esc = true; continue; }
      if (ch === '"') { inStr = !inStr; continue; }
      if (!inStr) {
        if (ch === '[') { depth++; continue; }
        if (ch === ']') {
          if (depth === 0) return i;
          depth--;
        }
      }
    }
    return -1;
  }

  static apply(line, scope, resolver, stats) {
    if (!String(line).includes(PDL.IF_START)) return [line, false];

    function evalChain(rawCond) {
      const cleaned = resolveNestedInExpr(rawCond, scope, resolver);
      const m = cleaned.match(/\sci=(true|false)\s*$/i);
      const defaultCi = !!(m && m[1].toLowerCase() === 'true');
      const condCore = m ? cleaned.slice(0, m.index).trimEnd() : cleaned;
      return resolver.evalCondition(condCore, scope, { default_ci: defaultCi });
    }

    let s = String(line);
    let changedAny = false;

    while (true) {
      const start = s.indexOf(PDL.IF_START);
      if (start === -1) break;
      const end = s.indexOf(PDL.IF_END, start);
      if (end === -1) { stats.errors_inline++; break; }

      const condStart = start + PDL.IF_START.length;
      const condClose = InlineIfHelper.findClosingBracket(s, condStart, end);
      if (condClose === -1) { stats.errors_inline++; break; }

      const condIf = s.slice(condStart, condClose).trim();
      let cursor = condClose + 1;

      const parts = [];
      const readUntilNextTag = (cpos) => {
        const nextElif = s.indexOf(PDL.ELIF, cpos);
        const nextElse = s.indexOf(PDL.ELSE, cpos);
        const candidates = [nextElif, nextElse, end].filter(x => x !== -1 && x <= end);
        const stop = candidates.length ? Math.min(...candidates) : end;
        return [s.slice(cpos, stop), stop];
      };

      let [textIf, cur2] = readUntilNextTag(cursor);
      cursor = cur2;
      parts.push([condIf, textIf]);

      while (cursor < end) {
        if (s.startsWith(PDL.ELIF, cursor)) {
          cursor += PDL.ELIF.length;
          const rb = InlineIfHelper.findClosingBracket(s, cursor, end);
          if (rb === -1) { stats.errors_inline++; break; }
          const cnd = s.slice(cursor, rb).trim();
          cursor = rb + 1;
          const [txt, c3] = readUntilNextTag(cursor);
          cursor = c3;
          parts.push([cnd, txt]);
          continue;
        }
        if (s.startsWith(PDL.ELSE, cursor)) {
          cursor += PDL.ELSE.length;
          const [txt, c3] = readUntilNextTag(cursor);
          cursor = c3;
          parts.push([null, txt]);
          break;
        }
        break;
      }

      let chosen = '';
      let triggered = false;
      for (const [cond, text] of parts) {
        if (cond == null) {
          if (!triggered) chosen = text;
          break;
        }
        if (evalChain(cond)) {
          stats.conds_true++;
          chosen = text;
          triggered = true;
          break;
        } else {
          stats.conds_false++;
        }
      }

      s = s.slice(0, start) + chosen + s.slice(end + PDL.IF_END.length);
      changedAny = true;
    }

    const dropLine = changedAny && s.trim() === '';
    return [s, dropLine];
  }
}

class InlineLoopExpander {
  static findHeaderEnd(s) {
    let inStr = false, esc = false, depth = 0;
    for (let i = 0; i < s.length; i++) {
      const ch = s[i];
      if (esc) { esc = false; continue; }
      if (ch === '\\' && inStr) { esc = true; continue; }
      if (ch === '"') { inStr = !inStr; continue; }
      if (!inStr) {
        if (ch === '[') { depth++; continue; }
        if (ch === ']') {
          if (depth === 0) return i;
          depth--;
        }
      }
    }
    return -1;
  }

  static apply(line, scope, resolver, stats) {
    const original = String(line);
    let s = original;
    while (true) {
      const a = s.indexOf(PDL.LOOP_START);
      if (a === -1) break;
      const b = s.indexOf(PDL.LOOP_END, a);
      if (b === -1) break;

      const headAndRest = s.slice(a + PDL.LOOP_START.length, b);
      const rb = InlineLoopExpander.findHeaderEnd(headAndRest);
      if (rb === -1) break;

      const head = headAndRest.slice(0, rb).trim();
      const body = headAndRest.slice(rb + 1);

      const params = parseKvFlags(head, {
        firstPositional: 'path',
        types: { as: String, start: Number, join: String, empty: String, dots: Boolean, ci: Boolean },
        defaults: { as: null, start: 1, join: null, empty: null, dots: true, ci: false },
      });

      const arr = resolver.resolveForLoop(String(params.path), scope, { default_ci: Boolean(params.ci) });

      const rendered = [];
      let hitLimit = false;
      for (let k = 0; k < arr.length; k++) {
        if (!bumpExp(stats, 1)) {
          hitLimit = true;
          break;
        }
        const item = arr[k];
        const childScope = new Scope({
          root: scope.root,
          aliases: { ...scope.aliases, ...(params.as ? { [params.as]: item } : {}) },
          index_chain: [...scope.index_chain, Number(params.start) + k],
          dots: Boolean(params.dots),
          var_frames: [...scope.var_frames, Object.create(null)],
        });

        let seg = body;
        let drop;
        [seg, drop] = InlineIfHelper.apply(seg, childScope, resolver, stats);
        if (!drop) {
          seg = InlineLoopExpander.apply(seg, childScope, resolver, stats);
          seg = expandValuesAndGetInline(seg, childScope, resolver, stats);
          const segClean = seg.trim();
          if (segClean !== '') rendered.push(segClean);
        }
      }

      let repl = '';
      if (!rendered.length) repl = params.empty ? String(params.empty) : '';
      else repl = (params.join != null) ? rendered.join(String(params.join)) : rendered.join('');

      s = s.slice(0, a) + repl + s.slice(b + PDL.LOOP_END.length);
      if (hitLimit) return s;
    }
    return s;
  }
}

class InlineSetDirective {
  apply(line, scope, resolver, stats) {
    let s = String(line);
    while (true) {
      const a = s.indexOf(PDL.SET_PREFIX);
      if (a === -1) break;

      let p = a, depth = 0, end = -1;
      while (p < s.length) {
        const ch = s[p];
        if (ch === '[') depth++;
        else if (ch === ']') {
          depth--;
          if (depth === 0) { end = p; break; }
        }
        p++;
      }
      if (end === -1) break;

      const inner = s.slice(a + PDL.SET_PREFIX.length, end).trim();
      let parts;
      try { parts = splitArgs(inner); } catch { parts = inner.split(/\s+/); }
      const head = (parts.length ? parts[0] : '').trim();
      const flagsRaw = parts.slice(1).join(' ').trim();

      let name = head;
      let rawValue = null;
      if (head.includes('=')) {
        const idx = head.indexOf('=');
        name = head.slice(0, idx).trim();
        rawValue = head.slice(idx + 1).trim();
      }

      const params = parseKvFlags(flagsRaw, {
        types: { const: Boolean, humble: Boolean, scope: Boolean },
        defaults: null,
      });

      const hadConst = Object.prototype.hasOwnProperty.call(params, 'const');
      const hadHumble = Object.prototype.hasOwnProperty.call(params, 'humble');
      const hadScope = Object.prototype.hasOwnProperty.call(params, 'scope');

      if (!VAR_NAME_RE.test(String(name || ''))) {
        s = s.slice(0, a) + s.slice(end + 1);
        continue;
      }

      const hasValue = rawValue != null;
      let valueObj = null;
      if (hasValue) {
        const expanded = resolveNestedInExpr(rawValue, scope, resolver);
        valueObj = parseScalarOrJson(expanded);
      }

      const constFlag = hadConst ? Boolean(params.const) : null;
      const humbleFlag = hadHumble ? Boolean(params.humble) : null;
      let scopeLocal = hadScope ? Boolean(params.scope) : false;
      if (scopeLocal && scope.var_frames.length === 1) scopeLocal = false;

      const targetFrameIndex = scopeLocal ? (scope.var_frames.length - 1) : 0;
      const targetFrame = scope.var_frames[targetFrameIndex];
      const bindingInTarget = targetFrame[name];

      if (hasValue) {
        const allowFlipUpdate = Boolean(bindingInTarget && bindingInTarget.const && hadConst && constFlag === false);
        scope.setVar(name, valueObj, {
          scope_local: scopeLocal,
          constFlag,
          humbleFlag,
          allow_value_update_if_const_flip: allowFlipUpdate,
        });
      } else {
        if (bindingInTarget) {
          if (hadConst) bindingInTarget.const = Boolean(constFlag);
          if (hadHumble) bindingInTarget.humble = Boolean(humbleFlag);
        }
      }

      s = s.slice(0, a) + s.slice(end + 1);
    }
    return s;
  }
}

// ================================================================
// 8) Inline value/get expansion
// ================================================================

function expandValuesAndGetInline(text, scope, resolver, stats) {
  const t = String(text || '');
  if (!t.includes(PDL.VALUE_PREFIX) && !t.includes(PDL.LOOP_IDX) && !t.includes(PDL.GET_PREFIX)) return t;

  let out = '';
  let i = 0;

  while (i < t.length) {
    const aVal = t.indexOf(PDL.VALUE_PREFIX, i);
    const aIdx = t.indexOf(PDL.LOOP_IDX, i);
    const aGet = t.indexOf(PDL.GET_PREFIX, i);

    const candidates = [];
    if (aVal !== -1) candidates.push(['val', aVal]);
    if (aIdx !== -1) candidates.push(['idx', aIdx]);
    if (aGet !== -1) candidates.push(['get', aGet]);

    if (!candidates.length) { out += t.slice(i); break; }

    candidates.sort((x, y) => x[1] - y[1]);
    const [kind, a] = candidates[0];
    out += t.slice(i, a);

    if (kind === 'idx') {
      if (!bumpExp(stats, 1)) { out += t.slice(a); break; }
      out += formatIndex(scope.index_chain, scope.dots);
      i = a + PDL.LOOP_IDX.length;
      continue;
    }

    let p = a;
    let depth = 0;
    let end = -1;
    while (p < t.length) {
      const ch = t[p];
      if (ch === '[') depth++;
      else if (ch === ']') {
        depth--;
        if (depth === 0) { end = p; break; }
      }
      p++;
    }
    if (end === -1) { out += t.slice(a); break; }

    const prefixLen = (kind === 'val') ? PDL.VALUE_PREFIX.length : PDL.GET_PREFIX.length;
    const innerRaw = t.slice(a + prefixLen, end).trim();

    // find first whitespace not inside brackets or quotes
    const findSplit = (s) => {
      let depth = 0, inS = false, inD = false, esc = false;
      for (let idx = 0; idx < s.length; idx++) {
        const ch = s[idx];
        if (esc) { esc = false; continue; }
        if (ch === '\\\\' && (inS || inD)) { esc = true; continue; }
        if (ch === '\'' && !inD) { inS = !inS; continue; }
        if (ch === '"' && !inS) { inD = !inD; continue; }
        if (!inS && !inD) {
          if (ch === '[') depth++;
          else if (ch === ']' && depth > 0) depth--;
          else if (depth === 0 && /\s/.test(ch)) return idx;
        }
      }
      return -1;
    };

    const splitIdx = findSplit(innerRaw);
    // if (process.env.PDL_DEBUG) {
    //   console.log('DEBUG innerRaw', JSON.stringify(innerRaw), 'splitIdx', splitIdx);
    // }
    const head = (splitIdx === -1) ? innerRaw : innerRaw.slice(0, splitIdx).trim();
    const paramsRaw = (splitIdx === -1) ? '' : innerRaw.slice(splitIdx).trim();

    const params = parseKvFlags(paramsRaw, {
      types: {
        escapeMarkdown: Boolean, trim: Boolean,
        upper: Boolean, lower: Boolean, title: Boolean,
        lowerCamel: Boolean, upperCamel: Boolean,
        lowerSnake: Boolean, upperSnake: Boolean,
        truncate: Number,
        stringify: Boolean, ci: Boolean,
        time: String,
        date: String,
        empty: String,
        unit: String,
        success: String,
        failure: String,
        fallback: String,
      },
      defaults: {
        escapeMarkdown: false, trim: false,
        upper: false, lower: false, title: false,
        lowerCamel: false, upperCamel: false,
        lowerSnake: false, upperSnake: false,
        truncate: 0,
        stringify: false, ci: false,
        time: null,
        date: null,
        empty: null,
        unit: 'ms',
        success: null,
        failure: null,
        fallback: null,
      },
    });

    if (!bumpExp(stats, 1)) { out += t.slice(a); break; }

    let original;
    if (kind === 'val') {
      const resolvedPath = resolveNestedInExpr(head, scope, resolver);
      // if (process.env.PDL_DEBUG) {
      //   console.log('DEBUG resolvedPath', resolvedPath, 'aliases', Object.keys(scope.aliases||{}), 'root keys', Object.keys(scope.root||{}));
      // }
      // Manual selector handling first (supports ^=, $=, *= with ci)
      if (original == null && typeof resolvedPath === 'string') {
        const pathStr = String(resolvedPath).trim();
        const m = pathStr.match(/^([A-Za-z_]\w*)\.([A-Za-z_]\w*)\[(.+)\]\.([A-Za-z_]\w*)$/);
        if (m) {
          const baseObj =
            (scope.aliases && Object.prototype.hasOwnProperty.call(scope.aliases, m[1]))
              ? scope.aliases[m[1]]
              : (scope.root && Object.prototype.hasOwnProperty.call(scope.root, m[1]) ? scope.root[m[1]] : null);
          if (baseObj && typeof baseObj === 'object' && !Array.isArray(baseObj)) {
            const arr = baseObj[m[2]];
            if (Array.isArray(arr)) {
              const sel = m[3].trim();
              const key = m[4];
              const ci = Boolean(params.ci);
              const opMatch = sel.match(/^([A-Za-z_]\w*)\s*(<|<=|>|>=|=|\^=|\$=|\*=)\s*(.+)$/);
              if (opMatch) {
                const k = opMatch[1];
                const op = opMatch[2];
                let rhs = opMatch[3].trim();
                if ((rhs.startsWith('"') && rhs.endsWith('"')) || (rhs.startsWith("'") && rhs.endsWith("'"))) {
                  rhs = rhs.slice(1, -1);
                }
                const cmp = (L, R) => {
                  if (ci && typeof L === 'string' && typeof R === 'string') {
                    L = L.toLowerCase();
                    R = R.toLowerCase();
                  }
                  if (op === '=') return L === R;
                  if (op === '^=') return typeof L === 'string' && L.startsWith(R);
                  if (op === '$=') return typeof L === 'string' && L.endsWith(R);
                  if (op === '*=') return typeof L === 'string' && L.includes(R);
                  return false;
                };
                for (const it of arr) {
                  if (it && typeof it === 'object' && Object.prototype.hasOwnProperty.call(it, k)) {
                    const L = normalizeStr(it[k]);
                    const R = normalizeStr(rhs);
                    if (cmp(L, R)) {
                      if (Object.prototype.hasOwnProperty.call(it, key)) {
                        original = it[key];
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (original == null) {
        original = resolver.resolveScoped(resolvedPath, scope, { default_ci: Boolean(params.ci) });
        if (original == null && typeof resolvedPath === 'string' && resolvedPath.includes('[')) {
          const altArr = resolver.resolveForLoop(resolvedPath, scope, { default_ci: Boolean(params.ci) });
          if (Array.isArray(altArr) && altArr.length) original = altArr[0];
        }
      }
    } else {
      const name = head;
      original = VAR_NAME_RE.test(String(name || '')) ? scope.getVarValue(name) : null;
    }

    let valueOut = original;
    let resolved = (valueOut != null);

    // detect forbidden default= usage (no back-compat). If present in paramsRaw, count parse error.
    if (/\bdefault\s*=/.test(paramsRaw)) {
      stats.errors_parse++;
    }

    // try fallback only if primary unresolved
    if (!resolved && params.fallback != null && params.fallback !== '') {
      const defExpr = String(stripOuterQuotes(params.fallback));
      const defPath = resolveNestedInExpr(defExpr, scope, resolver);
      const defResolved = resolver.resolveScoped(defPath, scope, { default_ci: Boolean(params.ci) });
      if (defResolved != null) {
        valueOut = defResolved;
        resolved = true;
      }
    }

    if (!resolved) {
      if (params.failure != null && params.failure !== '') {
        valueOut = params.failure;
      } else {
        // keep original directive text if unresolved and no fallback
        out += t.slice(a, end + 1);
        i = end + 1;
        continue;
      }
    } else if (typeof valueOut === 'string' && valueOut === '') {
      if (params.empty != null && params.empty !== '') {
        valueOut = params.empty;
      } else {
        valueOut = '';
      }
    } else {
      if (params.success != null && params.success !== '') {
        valueOut = params.success;
      }
    }

    if (/\bformat\s*=/.test(paramsRaw)) {
      stats.errors_parse++;
    }

    const hasDate = params.date != null && params.date !== '';
    const hasTime = params.time != null && params.time !== '';
    if (hasDate && hasTime) {
      stats.errors_parse++;
      valueOut = PDL.INVALID_TIME_DEFAULT;
    } else if (hasDate) {
      const [ms, bad] = parseDateInput(valueOut);
      if (ms == null || bad) {
        stats.errors_parse++;
        valueOut = PDL.INVALID_DATE_DEFAULT;
      } else {
        const comp = componentsFromDateMs(ms, PDL.DATE_TZ);
        valueOut = renderTokens(String(params.date), comp, 'date');
      }
    } else if (hasTime) {
      let emptyTime = params.empty;
      if (emptyTime == null || emptyTime === '') emptyTime = PDL.INVALID_TIME_DEFAULT;

      const unit = String(params.unit || 'ms').trim().toLowerCase();
      const num = coerceNumber(valueOut);
      if (num == null) {
        stats.errors_parse++;
        valueOut = String(emptyTime);
      } else {
        let numMs = Number(num);
        if (unit === 'ms') { /* no-op */ }
        else if (unit === 's') numMs = numMs * 1000;
        else if (unit === 'm') numMs = numMs * 60000;
        else if (unit === 'h') numMs = numMs * 3600000;
        else if (unit === 'd') numMs = numMs * 86400000;
        else { stats.errors_parse++; valueOut = String(emptyTime); numMs = null; }

        if (numMs != null) {
          const comp = breakDownDuration(numMs);
          const fmt = String(params.time);
          const cleaned = String(fmt || '');
          const hasLettersOutsideTokens = /[A-Za-z]/.test(cleaned.replace(/%[YymdHMSL]/g, ''));
          if (!hasLettersOutsideTokens) {
            const order = ['Y','m','d','H','M','S','L'];
            const words = {Y:'year',m:'month',d:'day',H:'hour',M:'minute',S:'second',L:'millisecond'};
            const seq = order.map(tok => ({tok, val: comp[tok]}));
            const first = seq.findIndex(x => x.val !== 0);
            const last = (() => { for (let i=seq.length-1;i>=0;i--) if (seq[i].val!==0) return i; return -1;})();
            if (first === -1 || last === -1) {
              valueOut = '0 seconds';
            } else {
              const parts = [];
              for (let idx = first; idx <= last; idx++) {
                const {tok,val} = seq[idx];
                parts.push(`${val} ${plural(val, words[tok])}`);
              }
              valueOut = parts.join(' ');
            }
          } else {
            valueOut = renderTokens(fmt, comp, 'duration');
          }
        }
      }
    }

    if (typeof valueOut === 'string') {
      if (params.replace != null && params.replace !== '') valueOut = applyReplace(valueOut, stripOuterQuotes(params.replace));
      if (Boolean(params.escapeMarkdown)) valueOut = markdownEscape(valueOut);
      if (Boolean(params.trim)) valueOut = valueOut.trim();

      valueOut = applyCaseBasic(valueOut, { upper: !!params.upper, lower: !!params.lower, title: !!params.title });
      if (params.lowerCamel) valueOut = camelCase(valueOut, false);
      if (params.upperCamel) valueOut = camelCase(valueOut, true);
      if (params.lowerSnake) valueOut = snakeCase(valueOut, false);
      if (params.upperSnake) valueOut = snakeCase(valueOut, true);

      const trunc = params.truncate;
      if (Number.isInteger(trunc) && trunc > 0) valueOut = applyTruncate(valueOut, trunc, params.suffix);
    }

    let textOut = toRenderText(valueOut, Boolean(params.stringify));
    if (textOut == null) textOut = '';

    out += textOut;
    i = end + 1;
  }

  return out;
}

// ================================================================
// 7) Engine (block directives + inline pipeline)
// ================================================================

class IfBlockDirective {
  constructor() {
    this._IF = /^\s*\[if:(.+)\]\s*$/;
    this._ELIF = /^\s*\[if-elif:(.+)\]\s*$/;
    this._ELSE = /^\s*\[if-else\]\s*$/;
    this._END = /^\s*\[if-end\]\s*$/;
  }
  match(line) { return this._IF.test(line); }

  expand(engine, lines, i, scope, depth) {
    const mIf = lines[i].match(this._IF);
    const condRoot = mIf ? mIf[1].trim() : '';

    let depthCtr = 1;
    let j = i + 1;
    const branches = [];
    let curCond = condRoot;
    let curBlock = [];
    let seenElse = false;

    while (j < lines.length) {
      const lRaw = lines[j];
      const [lNorm] = InlineIfHelper.apply(lRaw, scope, engine.resolver, engine.stats);

      if (this._IF.test(lNorm)) { depthCtr++; curBlock.push(lRaw); }
      else if (this._END.test(lNorm)) {
        depthCtr--;
        if (depthCtr === 0) { branches.push([curCond, curBlock]); j++; break; }
        curBlock.push(lRaw);
      } else if (depthCtr === 1 && !seenElse && this._ELIF.test(lNorm)) {
        const mElif = lNorm.match(this._ELIF);
        branches.push([curCond, curBlock]);
        curCond = mElif ? mElif[1].trim() : '';
        curBlock = [];
      } else if (depthCtr === 1 && !seenElse && this._ELSE.test(lNorm)) {
        branches.push([curCond, curBlock]);
        curCond = null;
        curBlock = [];
        seenElse = true;
      } else {
        curBlock.push(lRaw);
      }
      j++;
    }

    function evalCond(expr) {
      const m = String(expr).match(/\sci=(true|false)\s*$/i);
      const ci = !!(m && m[1].toLowerCase() === 'true');
      const core = m ? String(expr).slice(0, m.index).trimEnd() : String(expr);
      const core2 = resolveNestedInExpr(core, scope, engine.resolver);
      return engine.resolver.evalCondition(core2, scope, { default_ci: ci });
    }

    let chosen = [];
    let triggered = false;
    for (const [cond, block] of branches) {
      if (cond == null) { if (!triggered) chosen = block; break; }
      if (evalCond(cond)) { engine.stats.conds_true++; chosen = block; triggered = true; break; }
      else engine.stats.conds_false++;
    }

    const emitted = engine.expandLines(
      chosen,
      new Scope({
        root: scope.root,
        aliases: scope.aliases,
        index_chain: scope.index_chain,
        dots: scope.dots,
        var_frames: [...scope.var_frames, Object.create(null)],
      }),
      depth + 1
    );

    if (!emitted.length && j < lines.length) {
      const [probe] = InlineIfHelper.apply(lines[j], scope, engine.resolver, engine.stats);
      if (probe.trim() === '') return [emitted, j + 1];
    }

    return [emitted, j];
  }
}

class LoopBlockDirective {
  constructor() {
    this._START = /^\s*\[loop:(.+)\]\s*$/;
    this._END = /^\s*\[loop-end\]\s*$/;
  }
  match(line) { return this._START.test(line); }

  expand(engine, lines, i, scope, depth) {
    const m = lines[i].match(this._START);
    const raw = m ? m[1] : '';

    const params = parseKvFlags(raw, {
      firstPositional: 'path',
      types: { as: String, start: Number, join: String, empty: String, dots: Boolean, ci: Boolean },
      defaults: { as: null, start: 1, join: null, empty: null, dots: true, ci: false },
    });

    let depthCtr = 1;
    let j = i + 1;
    while (j < lines.length && depthCtr > 0) {
      const ln = lines[j];
      const [lnNorm] = InlineIfHelper.apply(ln, scope, engine.resolver, engine.stats);
      if (this._START.test(lnNorm)) depthCtr++;
      else if (this._END.test(lnNorm)) depthCtr--;
      j++;
    }

    const body = lines.slice(i + 1, j - 1);
    engine.stats.loops++;

    const arr = engine.resolver.resolveForLoop(String(params.path), scope, { default_ci: Boolean(params.ci) });

    let nextIsBlank = false;
    if (j < lines.length) {
      const [probe] = InlineIfHelper.apply(lines[j], scope, engine.resolver, engine.stats);
      nextIsBlank = (probe.trim() === '');
    }

    if (!Array.isArray(arr) || arr.length === 0) {
      if (params.empty) return [[String(params.empty)], j];
      return [[], j];
    }

    const iterBlocks = [];
    for (let k = 0; k < arr.length; k++) {
      if (!bumpExp(engine.stats, 1)) break;
      const item = arr[k];
      const newIndex = [...scope.index_chain, Number(params.start) + k];
      const childScope = new Scope({
        root: scope.root,
        aliases: { ...scope.aliases, ...(params.as ? { [params.as]: item } : {}) },
        index_chain: newIndex,
        dots: Boolean(params.dots),
        var_frames: [...scope.var_frames, Object.create(null)],
      });

      const subLines = engine.expandLines(body, childScope, depth + 1);
      const resolved = subLines.map(ln => expandValuesAndGetInline(ln, childScope, engine.resolver, engine.stats));
      if (resolved.some(x => x.trim() !== '')) iterBlocks.push(resolved);
      if (engine.stats.halted) break;
    }

    if (engine.stats.halted) {
      // stop expansion here; keep already-rendered iterations; remainder of template will stay literal
      const merged = Engine.coalesceLoopBlocks(iterBlocks);
      return [merged, j];
    }

    let merged;
    if (params.join != null) {
      const joinedBlocks = iterBlocks.map(b => b.join('\n'));
      merged = joinedBlocks.join(String(params.join)).split('\n');
    } else {
      merged = Engine.coalesceLoopBlocks(iterBlocks);
    }

    if (nextIsBlank) {
      while (merged.length && merged[merged.length - 1].trim() === '') merged.pop();
    }

    return [merged, j];
  }
}

class Engine {
  constructor() {
    this.resolver = new PathResolver();
    this.stats = new RenderStats();
    this.blockRegistry = [new LoopBlockDirective(), new IfBlockDirective()];
    this.inlineRegistry = [
      new InlineSetDirective(),
      { apply: (line, scope, resolver, stats) => InlineLoopExpander.apply(line, scope, resolver, stats) },
      { apply: (line, scope, resolver, stats) => expandValuesAndGetInline(line, scope, resolver, stats) },
    ];
  }

  _checkLimits(depth) {
    if (this.stats.halted) return true;
    if (depth > PDL.MAX_DEPTH) { this.stats.errors_parse++; this.stats.halted = true; return true; }
    return false;
  }

  static trimBlockEdges(block) {
    if (!block || !block.length) return block;
    let lead = 0;
    while (lead < block.length && block[lead].trim() === '') lead++;
    const keptLead = lead > 0 ? 1 : 0;

    let trail = 0;
    for (let t = block.length - 1; t - trail >= 0 && block[t - trail].trim() === ''; trail++) {}
    const keptTrail = trail > 0 ? 1 : 0;

    const core = block.slice(lead, (trail > 0 ? block.length - trail : block.length));
    const out = [];
    if (keptLead) out.push('');
    out.push(...core);
    if (keptTrail) out.push('');
    return out;
  }

  static coalesceLoopBlocks(blocks) {
    const out = [];
    for (const b of blocks) {
      const bb = Engine.trimBlockEdges(b);
      if (!out.length) { out.push(...bb); continue; }
      let k = 0;
      if (out.length && out[out.length - 1].trim() === '') {
        while (k < bb.length && bb[k].trim() === '') k++;
      }
      out.push(...bb.slice(k));
    }
    return out;
  }

  expandLines(lines, scope, depth=0) {
    const emitted = [];
    let i = 0;
    const n = lines.length;
    let previousWasBlank = false;

    while (i < n) {
      if (this._checkLimits(depth)) { emitted.push(...lines.slice(i)); break; }

      const raw = lines[i];

      let line, drop;
      [line, drop] = InlineIfHelper.apply(raw, scope, this.resolver, this.stats);
      if (drop) { i++; continue; }

      let usedBlock = false;
      for (const directive of this.blockRegistry) {
        if (directive.match(line)) {
          const [blk, newI] = directive.expand(this, lines, i, scope, depth);
          emitted.push(...blk);
          i = newI;
          usedBlock = true;
          previousWasBlank = (blk.length === 0) || blk.every(x => x.trim() === '');
          if (this.stats.halted) { emitted.push(...lines.slice(i)); break; }
          break;
        }
      }
      if (this.stats.halted) break;
      if (usedBlock) continue;

      const originalLine = line;
      for (const inline of this.inlineRegistry) {
        line = inline.apply(line, scope, this.resolver, this.stats);
        if (this.stats.halted) {
          // preserve current line as-is plus remainder lines literal
          emitted.push(line);
          emitted.push(...lines.slice(i + 1));
          return emitted;
        }
      }

      const onlySpaces = line.trim() === '';
      const onlySet =
        onlySpaces &&
        originalLine.includes('[set:') &&
        !originalLine.includes('[get:') &&
        !originalLine.includes('[value:') &&
        !originalLine.includes('[loop:') &&
        !originalLine.includes('[if:');

      if (onlySet) {
        if (!previousWasBlank && emitted.length && emitted[emitted.length - 1].trim() !== '') emitted.push('');
        i++;
        previousWasBlank = true;
        continue;
      }

      if (line.trim() === '') {
        if (!previousWasBlank) { emitted.push(''); previousWasBlank = true; }
      } else {
        emitted.push(line);
        previousWasBlank = false;
      }

      i++;
    }

    return emitted;
  }
}

// ================================================================
// 9) Condense post-pass
// ================================================================

class CondenseProcessor {
  static _applyRules(s) {
    if (s == null) return '';
    let x = String(s);
    x = x.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    x = x.replace(/\n/g, ' ');
    x = x.replace(/ {2,}/g, ' ');
    x = x.replace(/\s+([.,!?;])/g, '$1');
    x = x.replace(/\(\s+/g, '(');
    x = x.replace(/\s+\)/g, ')');
    x = x.replace(/\(, /g, '(').replace(/, \)/g, ')');
    x = x.replace(/\( /g, '(').replace(/ \)/g, ')');
    return x.trim();
  }

  static applyAll(text) {
    const startTok = PDL.CONDENSE_START;
    const endTok = PDL.CONDENSE_END;
    if (!String(text).includes(startTok) && !String(text).includes(endTok)) return text;

    let s = String(text);
    const stack = [];
    let i = 0;

    while (i < s.length) {
      const a = s.indexOf(startTok, i);
      const b = s.indexOf(endTok, i);

      if (a === -1 && b === -1) break;

      if (a !== -1 && (b === -1 || a < b)) {
        stack.push(a);
        i = a + startTok.length;
        continue;
      }

      if (b !== -1) {
        if (stack.length) {
          const startIdx = stack.pop();
          const inner = s.slice(startIdx + startTok.length, b);
          const replaced = CondenseProcessor._applyRules(inner);
          s = s.slice(0, startIdx) + replaced + s.slice(b + endTok.length);
          i = startIdx + replaced.length;
          continue;
        } else {
          s = s.slice(0, b) + s.slice(b + endTok.length);
          i = b;
          continue;
        }
      }
    }

    while (stack.length) {
      const idx = stack.pop();
      s = s.slice(0, idx) + s.slice(idx + startTok.length);
    }
    return s;
  }
}

// ================================================================
// 10) PostFormat
// ================================================================

const PostFormat = {
  dropFirstHeaderLine(text, enabled) {
    if (!enabled) return text;
    const lines = String(text || '').split('\n');
    if (!lines.length) return text;
    if (/^(#{1,6})[ \t]+.+$/.test(lines[0])) {
      lines.shift();
      if (lines.length && lines[0].trim() === '') lines.shift();
    }
    return lines.join('\n');
  },

  applyHeaderLevelPreset(text, preset) {
    const pad = Math.max(0, (String(preset || '#').length - 1));
    if (pad === 0) return text;

    const out = [];
    let inCode = false;
    const fenceRe = /^(```|~~~)/;
    const headingRe = /^(#{1,6})([ \t]+)(.*)$/;

    for (const line of String(text || '').split('\n')) {
      if (fenceRe.test(line)) { inCode = !inCode; out.push(line); continue; }
      if (inCode) { out.push(line); continue; }

      const m = line.match(headingRe);
      if (!m) { out.push(line); continue; }

      const hashes = m[1];
      const rest = m[3];
      const newCount = Math.min(6, hashes.length + pad);
      out.push('#'.repeat(newCount) + ' ' + String(rest).trim());
    }

    return out.join('\n');
  },
};

// ================================================================
// 11) PDLParser
// ================================================================

class PDLParser {
  constructor(template, jsonRoot, { aliases = {}, variables = {} } = {}) {
    this.template = template;
    this.jsonRoot = jsonRoot;
    this.aliases = aliases;
    this.variables = variables;
    this.stats = new RenderStats();
  }

  render() {
    const stripped = CommentHandler.strip(this.template);
    const engine = new Engine();
    const scope = new Scope({ root: this.jsonRoot, aliases: this.aliases, index_chain: [], dots: true });
    if (this.variables && typeof this.variables === 'object') {
      for (const [k, v] of Object.entries(this.variables)) {
        scope.setVar(k, v, { constFlag: true });
      }
    }

    const expandedLines = engine.expandLines(stripped.split('\n'), scope, 0)
      .map(line => expandValuesAndGetInline(line, scope, engine.resolver, engine.stats));

    let text = expandedLines.join('\n');
    text = CondenseProcessor.applyAll(text);

    this.stats = engine.stats;
    return [text, this.stats];
  }
}

// ================================================================
// Run
// ================================================================

function normalizeRoot(raw) {
  const jsonRootRaw = (raw && typeof raw === 'object') ? raw : {};
  if (
    Array.isArray(jsonRootRaw) &&
    jsonRootRaw.length === 1 &&
    jsonRootRaw[0] &&
    typeof jsonRootRaw[0] === 'object'
  ) {
    return jsonRootRaw[0];
  }
  return jsonRootRaw;
}

/**
 * Render a PDL template with data.
 *
 * @param {string} template
 * @param {object} data
 * @param {object} options
 * @param {string} [options.headerIndentation='#'] - baseline header level (#, ##, ...)
 * @param {boolean} [options.dropFirstHeader=false] - drop the first heading line
 * @returns {{markdown: string, stats: object, rawStats: RenderStats}}
 */
function render(template, data, options = {}) {
  const { headerIndentation = '#', dropFirstHeader = false, variables = {} } = options;

  const jsonRoot = normalizeRoot(data);
  const templWithVars = applyStringVariables(String(template || ''), variables);

  const parser = new PDLParser(templWithVars, jsonRoot, {
    aliases: { data: jsonRoot },
    variables,
  });
  let [expandedText, stats] = parser.render();

  expandedText = PostFormat.dropFirstHeaderLine(expandedText, Boolean(dropFirstHeader));
  expandedText = PostFormat.applyHeaderLevelPreset(expandedText, String(headerIndentation || '#'));

  return {
    markdown: expandedText,
    stats: stats.summary(),
    rawStats: stats,
  };
}

return { render, PDL, PDLParser, PostFormat, RenderStats };
})();

if (typeof module !== 'undefined' && module.exports) {
  module.exports = PDL_LIB;
}
if (global) {
  global.PDL = PDL_LIB;
}
})(typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : this);
